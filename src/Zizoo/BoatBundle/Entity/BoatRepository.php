<?php

namespace Zizoo\BoatBundle\Entity;

use Zizoo\BoatBundle\Entity\Price;
use Zizoo\CharterBundle\Entity\Charter;
use Zizoo\BoatBundle\Extensions\DoctrineExtensions\CustomWalker\SortableNullsWalker;
use Zizoo\AddressBundle\Form\Model\SearchBoat;
use Zizoo\AddressBundle\Form\Model\FilterBoat;
use Zizoo\ReservationBundle\Entity\Reservation;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\Tools\Pagination\Paginator;
use Doctrine\ORM\Query;
use Doctrine\ORM\Query\ResultSetMapping;
use Doctrine\ORM\Query\Expr;
/**
 * BoatRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class BoatRepository extends EntityRepository
{
    public function getBoats($limit = null)
    {
        $qb = $this->createQueryBuilder('b')
                   ->select('b')
                   ->where('b.active = true')
                   ->andWhere('b.deleted IS NULL')
                   ->addOrderBy('b.created', 'DESC');

        if (false === is_null($limit))
            $qb->setMaxResults($limit);

        return $qb->getQuery()
                  ->getResult();
    }
    
    public function getCharterBoats($charter)
    {
        $qb = $this->createQueryBuilder('boat')
                   ->leftJoin('boat.charter', 'charter')
                   ->select('boat, charter')
                   ->where('charter = :charter')
                   ->andWhere('boat.deleted IS NULL')
                   ->setParameter('charter', $charter);

        return $qb->getQuery()
                  ->getResult();
    }
    
    
    public function searchBoatsQuery(SearchBoat $searchBoat, FilterBoat $filterBoat=null, $orderBy)
    {
        // Join boat, image, address, country and reservation
        $qb = $this->createQueryBuilder('boat')
                   ->select('boat, image, address, country, reservation, boat_type, equipment')
                   ->leftJoin('boat.image', 'image')
                   ->leftJoin('boat.address', 'address')
                   ->leftJoin('boat.address', 'boat_address')
                   ->leftJoin('address.country', 'country')
                   ->leftJoin('boat.reservation', 'reservation')
                   ->leftJoin('boat.boatType', 'boat_type')
                   ->leftJoin('boat.equipment', 'equipment');
        
        $firstWhere = true;
        // If check-in and check-out are defined and "available only" is true, don't get boats with reservation (accepted, self, hold) for specified dates
        $reservationStatus = array(Reservation::STATUS_ACCEPTED, Reservation::STATUS_SELF, Reservation::STATUS_HOLD);
        if ($searchBoat->getReservationFrom() && $searchBoat->getReservationTo() && $filterBoat && $filterBoat->getAvailableOnly()){
            $qb->where('(reservation.checkIn >= :res_to OR reservation.checkOut <= :res_from) OR reservation.status NOT IN ('.  implode(',', $reservationStatus).') OR reservation.id IS NULL')
                    ->setParameter('res_to', $searchBoat->getReservationTo())
                    ->setParameter('res_from', $searchBoat->getReservationFrom());
            $firstWhere = false;
        }
        
        // Optionally search by boat location or boat availability location
        if ($searchBoat->getLocation()){
            $qb->where('address.locality = :search')
               ->orWhere('address.subLocality = :search')
               ->orWhere('address.state = :search')
               ->orWhere('address.province = :search')
               ->orWhere('country.printableName = :search')
               ->setParameter('search', $searchBoat->getLocation());
            $firstWhere = false;
        }
        
        // Optionally restrict by boat type
        
        // Optionally restrict by number of guests
        if ($searchBoat->getNumGuests()){
            if ($firstWhere){
                $qb->where('boat.nr_guests >= :num_guests');
            } else {
                $qb->andWhere('boat.nr_guests >= :num_guests');
            }
            $qb->setParameter('num_guests', $searchBoat->getNumGuests());
            $firstWhere = false;
        }
        
        if ($filterBoat){
            // Optionally restrict by skippered only
            if ($filterBoat->getCrew()){
                if ($firstWhere){
                    $qb->where('boat.crewOptional = false');
                } else {
                    $qb->andWhere('boat.crewOptional = false');
                }
                $firstWhere = false;
            }
            
            // Optionally restrict by boat length
            if ($filterBoat->getLengthFrom()){
                if ($firstWhere){
                    $qb->where('boat.length >= :length_from');
                } else {
                    $qb->andWhere('boat.length >= :length_from');
                }
                $qb->setParameter('length_from', $filterBoat->getLengthFrom());
                $firstWhere = false;
            }
            if ($filterBoat->getLengthTo()){
                if ($firstWhere){
                    $qb->where('boat.length <= :length_to');
                } else {
                    $qb->andWhere('boat.length <= :length_to');
                }
                $qb->setParameter('length_to', $filterBoat->getLengthTo());
                $firstWhere = false;
            }

            // Optionally restrict by number of cabins
            if ($filterBoat->getNumCabinsFrom()){
                if ($firstWhere){
                    $qb->where('boat.cabins >= :num_cabins_from');
                } else {
                    $qb->andWhere('boat.cabins >= :num_cabins_from');
                }
                $qb->setParameter('num_cabins_from', $filterBoat->getNumCabinsFrom());
                $firstWhere = false;
            }
            if ($filterBoat->getNumCabinsTo()){
                if ($firstWhere){
                    $qb->where('boat.cabins <= :num_cabins_to');
                } else {
                    $qb->andWhere('boat.cabins <= :num_cabins_to');
                }
                $qb->setParameter('num_cabins_to', $filterBoat->getNumCabinsTo());
                $firstWhere = false;
            }

            // Optionally restrict by boat type
            if ($filterBoat->boatTypeSelected()){           
                $boatTypes = $filterBoat->getBoatType();
                $boatTypeIds = array();
                foreach ($boatTypes as $boatType){
                    $boatTypeIds[] = $boatType->getId();
                }
                if ($firstWhere){
                    $qb->where('boat.boatType IN (:boat_types)');
                } else {
                    $qb->andWhere('boat.boatType IN (:boat_types)');
                }
                $qb->setParameter('boat_types', $boatTypeIds);
                $firstWhere = false;

            }
            
            // Optionally restrict by equipment
            if ($filterBoat->equipmentSelected()){           
                $equipment = $filterBoat->getEquipment();
                $equipmentIds = array();
                foreach ($equipment as $e){
                    $equipmentIds[] = $e->getId();
                }
                if ($firstWhere){
                    $qb->where('equipment.id IN (:e)');
                } else {
                    $qb->andWhere('equipment.id IN (:e)');
                }
                $qb->setParameter('e', $equipmentIds);
                $firstWhere = false;

            }
            
            // Optionally restrict by price
            if ($filterBoat->getPriceFrom()){
                if ($firstWhere){
                    $qb->where('boat.lowestPrice >= :price_from');
                } else {
                    $qb->andWhere('boat.lowestPrice >= :price_from');
                }
                $qb->setParameter('price_from', $filterBoat->getPriceFrom());
                $firstWhere = false;
            }
            if ($filterBoat->getPriceTo()){
                if ($firstWhere){
                    $qb->where('boat.highestPrice <= :price_to');
                } else {
                    $qb->andWhere('boat.highestPrice <= :price_to');
                }
                $qb->setParameter('price_to', $filterBoat->getPriceTo());
                $firstWhere = false;
            }
        }
        
        if ($firstWhere){
            $qb->where('boat.active = true');
            $qb->andWhere('boat.deleted IS NULL');
            $qb->andWhere('boat.lowestPrice IS NOT NULL');
            $qb->andWhere('boat.highestPrice IS NOT NULL');
            $firstWhere = false;
        } else {
            $qb->andWhere('boat.active = true');
            $qb->andWhere('boat.deleted IS NULL');
            $qb->andWhere('boat.lowestPrice IS NOT NULL');
            $qb->andWhere('boat.highestPrice IS NOT NULL');
        }
        
//        if ($orderBy=='price'){
//            $qb->addOrderBy('reservation.id, boat.highestPrice', 'desc');
//            $sortableNullsWalker = SortableNullsWalker::NULLS_LAST;
//        } else {
//            $qb->addOrderBy('reservation.id, boat.created', 'desc');
//            $sortableNullsWalker = SortableNullsWalker::NULLS_FIRST;
//        }

        
        if ($orderBy=='price'){
//            $qb->addOrderBy('reservation.id, boat.lowestPrice', 'asc');
//            $hintArray = array(
//                            'reservation.id'    => SortableNullsWalker::NULLS_LAST,
//                            'boat.lowestPrice'  => 'asc'
//                        );
            $qb->addOrderBy('boat.lowestPrice', 'asc');
        }  else {
            // Date
//            $qb->addOrderBy('reservation.id, boat.created', 'desc');
//            $hintArray = array(
//                            'reservation.id'    => SortableNullsWalker::NULLS_FIRST,
//                            'boat.created, boat.id'      => 'desc'
//                        );
            $qb->addOrderBy('boat.created', 'desc');
        }
        
//        return $qb->getQuery()
//                  ->setHint(Query::HINT_CUSTOM_OUTPUT_WALKER, 'Zizoo\BoatBundle\Extensions\DoctrineExtensions\CustomWalker\SortableNullsWalker')
//                  ->setHint('SortableNullsWalker.fields',
//                        $hintArray);
        return $qb->getQuery();
    }
    
    /**
     * 
     * @author Alex Fuckert <alexf83@gmail.com>
     */
    public function searchBoats(SearchBoat $searchBoat, FilterBoat $filterBoat=null, $orderBy)
    {
        return $this->searchBoatsQuery($searchBoat, $filterBoat, $orderBy)
                  ->getResult();
    }
    
    
    public function getMaxBoatValues($boat = null){
        $qb = $this->createQueryBuilder('boat')
                   ->select('MAX(boat.cabins) as max_cabins, MAX(boat.length) as max_length, MAX(boat.highestPrice) as max_highest_price, MIN(boat.lowestPrice) as min_lowest_price');
        if ($boat){
            $qb->where('boat = :boat');
            $qb->andWhere('boat.active = TRUE');
            $qb->andWhere('boat.deleted IS NULL');
            $qb->setParameter('boat', $boat);
        }
        
        return $qb->getQuery()->getSingleResult();
    }
    
    public function getLatestCharterBoats(Charter $charter, $pageSize, $page)
    {
        $start = ($page-1)*($pageSize-1);
        $limit = $pageSize;
        $qb = $this->createQueryBuilder('boat')
                   ->leftJoin('boat.charter', 'charter')
                   ->select('boat')
                   ->where('charter = :charter')
                   ->andWhere('boat.active = TRUE')
                   ->andWhere('boat.deleted IS NULL')
                   ->setParameter('charter', $charter)
                   ->setFirstResult($start)
                   ->setMaxResults($limit);

        return $qb->getQuery()->getResult();
    }
    
    public function getNumberOfCharterBoats(Charter $charter, $active = FALSE, $complete = FALSE)
    {
        $qb = $this->createQueryBuilder('boat')
                   ->leftJoin('boat.charter', 'charter')
                   ->select('COUNT(boat.id) as num_boats')
                   ->where('charter = :charter')
                   ->andWhere('boat.active = :active')
                        ->setParameter('active', $active)
                   ->andWhere('boat.status = :status')
                        ->setParameter('status', $complete)
                   ->andWhere('boat.deleted IS NULL')
                        ->setParameter('charter', $charter);


        return $qb->getQuery()->getSingleScalarResult();
    }
    
    /**
    public function getPrices(Boat $boat, $from, $to){
        $rsm = new ResultSetMapping();
        $rsm->addEntityResult('Zizoo\BoatBundle\Entity\Price', 'p');
        $rsm->addFieldResult('p', 'id', 'id');
        $rsm->addFieldResult('p', 'available_from', 'available_from');
        $rsm->addFieldResult('p', 'available_until', 'available_until');
        $rsm->addFieldResult('p', 'price', 'price');
        $rsm->addFieldResult('p', 'date_range', 'date_range');
        $rsm->addFieldResult('p', 'date_range_before', 'date_range_before');
        $rsm->addFieldResult('p', 'date_range_after', 'date_range_after');
        $rsm->addMetaResult('p', 'boat_id', 'boat');

        $query = $this->_em->createNativeQuery('SELECT id, available_from, available_until, price, boat_id,'
                                                .' CASE
                                                        WHEN :from >= available_from AND :until <= available_until THEN DATEDIFF(:until, :from)
                                                        WHEN :from >= available_from AND :from < available_until AND :until > available_until THEN DATEDIFF(available_until, :from)
                                                        WHEN :from < available_from AND :until >= available_from AND :until <= available_until THEN DATEDIFF(:until, available_from)
                                                        WHEN :from < available_until AND :until > available_until THEN DATEDIFF(available_until, available_from)
                                                END AS date_range,'
                                                .' CASE
                                                        WHEN :from >= available_from AND :until <= available_until THEN DATEDIFF(available_from, :from)
                                                        WHEN :from >= available_from AND :from < available_until AND :until > available_until THEN NULL
                                                        WHEN :from < available_from AND :until >= available_from AND :until <= available_until THEN DATEDIFF(available_from, :from)
                                                        WHEN :from < available_until AND :until > available_until THEN DATEDIFF(available_from, :from)
                                                END AS date_range_before,'
                                                .' CASE
                                                        WHEN :from >= available_from AND :until <= available_until THEN NULL
                                                        WHEN :from >= available_from AND :from < available_until AND :until > available_until THEN DATEDIFF(:until, available_until)
                                                        WHEN :from < available_from AND :until >= available_from AND :until <= available_until THEN NULL
                                                        WHEN :from < available_until AND :until > available_until THEN DATEDIFF(:until, available_until)
                                                END AS date_range_after'
                                                .' FROM boat_price'
                                                .' WHERE boat_id = :boat_id'
                                                .' ORDER BY available_from ASC',
                                                $rsm);
        
        $query->setParameter('from', $from);
        $query->setParameter('until', $to);
        $query->setParameter('boat_id', $boat->getId());

        $prices = $query->getResult();
        
        return $prices;
    }*/
        
    
    
}
